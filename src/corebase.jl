# Methods for writing common data of input files, 

abstract type Analysis end

abstract type SolutionProcedure end

abstract type MechanicalAnalysis <: Analysis end
abstract type ThermalAnalysis <: Analysis end

struct Static3DStressAnalysis <: MechanicalAnalysis end
struct StaticPlaneStressAnalysis <: MechanicalAnalysis end
struct StaticPlaneStrainAnalysis <: MechanicalAnalysis end
struct Steady3DHeatConduction <: ThermalAnalysis end

struct SteadyStateDynamicDirectSolution <: SolutionProcedure end

struct MaterialPhase
    tag::String
    material
    econn::Dict
end


function get_analysis_type(
    prop_ID::String
)
    if prop_ID ∈ ["E22_3D", "E33_3D", "E11_3D", "G31_3D", "G12_3D", "G23_3D", "CTE_3D"]
        return Static3DStressAnalysis
    elseif prop_ID ∈ ["K11_3D", "K22_3D", "K33_3D"]
        return Steady3DHeatConduction
    elseif prop_ID ∈ ["E22_2D", "E33_2D", "G23_2D"]
        return StaticPlaneStrainAnalysis
    else
        @warn "Invalid property ID $prop_ID is encountered!"
    end
end


function initialize_inp_file(
    file_path::String,
    job_name::String="JOB",
    model_name::String="MODEL",
    model_summary::String="";
    echo_info::String="NO",
    print_model_info::String="NO",
    print_history::String="NO",
    print_contact_info::String="NO"
)
    # creating new file or clearing the contents of file, if any.
    create_new_file(file_path)
    #
    append_to_file(
        file_path,
        """
    *HEADING
    $(!isempty(model_summary) ? model_summary : "**")
    """
    )
    #
    append_to_file(file_path,
        """
        ** JOB NAME: $job_name 
        ** MODEL NAME: $model_name
        ** Generated by RVE
        *PREPRINT, ECHO=$echo_info, MODEL=$print_model_info, HISTORY=$print_history, CONTACT=$print_contact_info
        """)
end


function write_nodes_info(
    ntags::Vector{Int},
    ncoor::Matrix{Float64},
    dir::String,
)
    # =====================================
    #        adding NODAL data    
    # =====================================
    nodes_file = create_new_file(joinpath(dir, "nodes_info.inp"))
    open(nodes_file, "a") do fp
        for (k, nt) in enumerate(ntags)
            write(
                fp,
                """
      $nt, $(ncoor[1, k]), $(ncoor[2, k]), $(ncoor[3, k])
      """
            )
        end
    end
    return nodes_file
end


function write_felset_info(
    econn::Dict{Int,Matrix{Int}},
    tag::Union{String,Int},
    dir::String,
)::Dict{String,String}
    ele_sets::Dict{String,String} = Dict()
    for (elt, elt_table) in econn
        ele_inp = create_new_file(joinpath(dir, "$tag-ele_conn_$elt.inp"))
        ele_sets["$tag-$elt"] = write_matrix_to_file(ele_inp, elt_table)
    end
    return ele_sets
end


function start_part_data(inp_file::String, part_name::String="PART-1")
    open(inp_file, "a") do fp
        write(
            fp,
            """
            ** 
            *PART, NAME=$part_name
            """
        )
    end
end

function finish_part_data(inp_file::String)
    open(inp_file, "a") do fp
        write( # ENDING PART
            fp,
            """
            *END PART
            **
            """
        )
    end
end


function add_nodal_data(
    inp_file::String,
    node_info_file::String,
)
    open(inp_file, "a") do fp
        write(
            fp,
            """
            *NODE
            *INCLUDE, INPUT="$node_info_file"
            """
        )
    end
end


function add_elsets_data(
    inp_file::String,
    efiles::Dict{String,String},
    analysis_type::DataType,
)
    open(inp_file, "a") do fp
        for (elt_tag, ele_data_file_path) in efiles
            elt = parse(Int, split(elt_tag, "-")[2])
            abaqus_ele_type = get_abaqus_element_type(elt, analysis_type)
            write(
                fp,
                """
                **
                *ELEMENT, type=$abaqus_ele_type, ELSET=$elt_tag
                *INCLUDE, INPUT="$ele_data_file_path"
                """
            )
        end
    end
end

function add_elset_from_elsets(
    inp_file::String,
    elsets::Dict{String,String},
    tag::String,
)
    open(inp_file, "a") do fp
        write(
            fp,
            """
            **
            *ELSET, ELSET=$tag
            """
        )
        write_vector_to_file(
            fp,
            collect(keys(elsets)),
        )
    end
end


function add_nset_from_elsets(
    inp_file::String,
    elset_tag::String,
    nset_tag::String,
)
    open(inp_file, "a") do fp
        write(
            fp,
            """
            *NSET, NSET=$nset_tag, ELSET=$elset_tag
            """
        )
    end
end


function add_nset_on_instance(
    inp_file::String,
    nset_tag::String,
    inst_tag::String,
    ntags::Vector{Int},
)
    open(inp_file, "a") do fp
        write(
            fp,
            """
            *NSET, NSET=$nset_tag, INSTANCE=$inst_tag
            """
        )
        write_vector_to_file(
            fp,
            ntags,
        )
    end
end


function add_solid_section(
    inp_file::String,
    elset_tag::String,
    material_tag::String,
    section_tag::String;
    add_unit_thickness::Bool=false,
)
    open(inp_file, "a") do fp
        thkns = add_unit_thickness ? "1," : ","
        write(
            fp,
            """
            **
            ** SECTION: $section_tag)
            *SOLID SECTION, ELSET=$elset_tag, MATERIAL=$material_tag
            $thkns
            """
        )
    end
end


function write_materials_data(
    file_path::String,
    materials_data::Vector,
)
    open(file_path, "a") do fp
        write(
            fp,
            """
            ** 
            **
            ** ***********************************
            **          MATERIAL DATA
            ** ***********************************
            **
            """
        )
        for a_material_data in materials_data
            write(
                fp,
                """
                *MATERIAL, NAME=$(a_material_data.tag)
                """
            )
            #
            field_names = fieldnames(typeof(a_material_data))
            if (:E in field_names) && (:nu in field_names)
                write(
                    fp,
                    """
                    *ELASTIC
                    $(a_material_data.E), $(a_material_data.nu)
                    """
                )
            end
            if :alpha in field_names
                write(
                    fp,
                    """
                    *EXPANSION
                    $(a_material_data.alpha),
                    """
                )
            end
            if :K in field_names
                write(
                    fp,
                    """
                    *CONDUCTIVITY
                    $(a_material_data.K),
                    """
                )
            end
        end
    end
    #
end




function start_assembly(inp_file::String, assembly_name::String="Assembly-1")
    open(inp_file, "a") do fp
        write(
            fp,
            """
            **
            **
            ** ASSEMBLY
            **
            *ASSEMBLY, NAME=$assembly_name
            """
        )
    end
end


function finish_assembly(inp_file::String)
    open(inp_file, "a") do fp
        write(
            fp,
            """
            **
            **
            **
            *END ASSEMBLY
            """
        )
    end
end


function add_instance_of_part(inp_file::String, instance_name::String, part_name::String)
    open(inp_file, "a") do fp
        write(
            fp,
            """
            **
            *INSTANCE, NAME=$instance_name, PART=$part_name
            *END INSTANCE
            """
        )
    end
end

function add_reference_points(
    file_path::String,
    points::Dict{String,NTuple{3,Float64}};
    init_ref_node_num::Int64=1000000
)
    append_to_file(file_path,
        """
        **
        **
        **      REFERENCE POINTS
        **
        """)
    open(file_path, "a") do fp
        for (k, (rp_key, rp_loc)) in enumerate(points)
            write(fp,
                """
                *NODE
                $(init_ref_node_num+k-1), $(rp_loc[1]), $(rp_loc[2]), $(rp_loc[3])
                *NSET, NSET=$rp_key
                $(init_ref_node_num+k-1),
                """)
        end
    end
    append_to_file(file_path,
        """
        **
        **
        """)
end



function add_predefined_fields(
    inp_file::String,
    field_type::String,
    fields::Dict{String, Float64};
    field_name::String="PREDEFINED FIELD-1"
)
    open(inp_file, "a") do fp
        write(fp,
            """
            ** 
            ** PREDEFINED FIELDS
            ** 
            ** NAME: $field_name   TYPE: $field_type
            *INITIAL CONDITIONS, TYPE=$field_type
            """)
        for (k, v) in fields
            write(fp,
            """
            $k, $v
            """)
        end
    end
end












# """
# Mesh data, julia dict, should contain,
#     Nodal information as
#         `ntags` as a vector &
#         `ncoor` as matrix with three rows `x`, `y` and `z`
#     element information as
#         `econn` as Dict where, each key represents element type and value gives respective element connectivity.

# """
# function write_common_files(
#     dir::String,
#     mesh_data::Dict,
#     instance_name::String,
#     small_param=1e-06
# )::Dict
#     common_inp_files = Dict{String,String}()
#     println("writing COMMON INP files..!")

#     #
#     # =======================================================
#     #           adding matrix Element and nodal info 
#     # =======================================================
#     mat_ele_sets::Dict{String,String} = Dict()
#     for (elt, mat_ele_connectivity) in mesh_data["matrix_element_connectivity"]
#         abaqus_ele_type = get_abaqus_element_type(elt)
#         mat_ele_inp = create_new_file(joinpath(inp_dir, "matrix_ele_connectivity_$abaqus_ele_type.inp"))
#         write_matrix_to_file(mat_ele_inp, mat_ele_connectivity)
#         mat_ele_sets["MATRIX-ELEMENTS-SET-$abaqus_ele_type"] = mat_ele_inp
#     end
#     common_inp_files["MATRIX_ELE_CON_INP"] = mat_ele_sets
#     #
#     # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#     # ~~~~~~~ adding inclusions Element and nodal info ~~~
#     # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#     inc_ele_sets::Dict{String,String} = Dict()
#     for (elt, inc_ele_connectivity) in mesh_data["inclusions_element_connectivity"]
#         abaqus_ele_type = get_abaqus_element_type(elt)
#         inc_ele_inp = create_new_file(joinpath(inp_dir, "inclusions_ele_connectivity_$abaqus_ele_type.inp"))
#         write_matrix_to_file(inc_ele_inp, inc_ele_connectivity)
#         inc_ele_sets["INCLUSIONS-ELEMENTS-SET-$abaqus_ele_type"] = inc_ele_inp
#     end
#     common_inp_files["INCLUSIONS_ELE_CON_INP"] = inc_ele_sets
#     return common_inp_files
# end

